## 딥다이브 14장 - 19장

<hr>

### 14. 전역 변수의 문제점

<br>

1. 전역 변수 사용을 억제하는 방법에는 무엇이 있는가?

- 전역 변수 사용을 억제하기 위해서는 코드를 즉시 실행 함수로 감싸 변수를 즉시 실행 함수의 지역 변수로 만드는 방법이 있으며, 전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법이 있습니다. 이는 식별자 충돌을 방지할 수는 있으나 네임스페이스 객체 자체가 전역 변수에 할당되기 때문에 유용한 방법은 아닙니다. 또한 클로저를 기반으로 동작하는 모듈 패턴 방식을 사용하여 관련있는 함수와 변수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만들어 정보를 은닉할 때 유용하게 사용할 수 있습니다. 또한 ES6의 모듈을 사용하여 script 태그에 `type="module"` 어트리뷰트를 추가하여 전역 변수 사용을 억제하는 방법이 있습니다.

<br>

2. 변수의 생명 주기에 대해 설명해주세요

- 변수가 영원히 메모리 공간을 점유하는 것을 막기 위해 변수는 생명주기를 가지게 되는데, 이는 메모리 공간이 확보된 시점부터 메모리 공간이 해제되어 가용 메모리 풀에 반환되는 시점까지를 의미합니다. 전역 변수의 생명 주기는 애플리케이션의 생명 주기와 같으며, 지역 변수의 생명 주기는 함수 호출 시 생성되고 함수 종료 시 소멸하는 생명 주기를 가지고 있습니다.

<br>

3. 전역 변수의 문제점에 대해 설명해주세요

- 전역 변수는 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용한다는 문제점이 있습니다. 또한, 생명주기가 길기 때문에 메모리 리소스를 많이 소비하며 상태 변경의 위험성이 있으며, 스코프 체인 상 종점에 존재하기 때문에 검색 속도가 느리다는 문제가 있습니다.

<br>

4. 전역 변수를 반드시 사용해야 할 경우에 대해 설명해주세요

- 코드 어디서든 참조하고 할당할 수 있는 변수를 사용해야 할 때 전역 변수를 사용합니다.

<br>

5. 네임스페이스에 대해 설명해주세요

- 네임스페이스는 다른 공간과 구분하기 위해 정해놓은 영역을 의미하며, 이름들을 한 곳에 모아 충돌을 미리 방지하고 해당 이름으로 선언된 변수와 함수를 쉽게 가져다 사용할 수 있도록 만든 매커니즘입니다. 자바스크립트에서는 네임스페이스 기능이 존재하지 않지만 객체 리터럴과 즉시 실행 함수를 통해 기능을 대신하는 것이 가능합니다.

<hr>

### 15. let, const 키워드와 블록 레벨 스코프

<br>

1. var 키워드로 선언한 전역 변수와 let 키워드로 선언한 전역 변수의 차이를 설명해주세요.

- var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정합니다. 따라서 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 됩니다. 하지만 let 키워드는 블록 레벨 스코프를 따르기 때문에 함수 외부에서 let 키워드로 선언한 변수를 코드 블록에서 선언하여도 이는 지역 변수가 되며 외부에서 선언한 변수의 값이 바뀌지 않습니다.

<br>

2. var보다 let, const 사용을 권장하는 이유를 설명해주세요.

- var를 사용해 변수를 선언할 경우 재선언이 가능하며 함수 레벨 스코프이기 때문에 잘못하여 값을 재할당할 경우 에러가 발생해도 찾기 힘들며 호이스팅과 스코프를 고려해야 하기 때문에 재선언이 불가능하며 블록 레벨 스코프인 let과 const를 사용하는 것을 권장하고 있습니다. 또한 재할당이 필요하지 않은 경우에는 의도치 않은 재할당을 방지할 수 있기 때문에 const를 우선적으로 사용할 수 있습니다.

<br>

3. 일시적 사각지대(Temporal Dead Zone; TDZ)와 TDZ의 영향을 받는 구문들에 대해 설명해주세요.

- 일시적 사각지대란 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 의미하며 실행 컨텍스트에 변수는 등록되었지만 메모리가 할당되지 않아 접근할 수 없을 경우 참조 에러를 발생 시키는 경우를 말합니다. let과 const는 TDZ의 영향을 받는데 let은 선언 전 줄까지 TDZ의 영향을 받으며 const는 선언 및 초기화 전 줄까지 TDZ의 영향을 받기 때문에 선언 전에 변수에 접근할 경우 참조 에러가 발생하게 됩니다.

<br>

4. const 키워드로 선언한 값을 변경할 수 있는 방법에 대해 설명해주세요

- const 키워드는 재할당을 금지하는 것이며 불변을 의미하는 것은 아니기 때문에 const로 선언한 변수에 원시값이 아닌 객체를 할당할 경우 프로퍼티 동적 생성, 삭제, 값의 변경을 통해 객체를 변경하는 것이 가능합니다.

<br>

5. 클로저는 어떤 문제를 회피하기 위해 사용하는 방법인지 스코프를 들어 설명해주세요

- 클로저는 반환된 내부함수가 자신이 선언됐을 때의 렉시컬 환경인 스코프를 기억하여 자신이 선언됐을 때의 스코프 밖에서 호출되어도 그 스코프에 접근할 수 있는 함수를 말합니다. 즉, 실행 스택과 관련 없는 스코프의 변수를 스코프 체인에 의해 사용할 수 있게 된 형태를 의미합니다.

<hr>

### 16. 프로퍼티 어트리뷰트

<br>

1. attribute와 property의 차이점은 무엇인가요?

- 브라우저는 웹페이지를 파싱하여 DOM 객체를 생성하는데 이 때 브라우저가 인식하는 HTML 표준 속성이 attribute이며, 이 표준 속성을 사용해 DOM property를 만드는 것입니다.

<br>

2. 데이터 프로퍼티와 접근자 프로퍼티에 대해 설명해주세요.

- 데이터 프로퍼티란 키와 값으로 구성된 일반적으로 객체에 속해있는 프로퍼티를 말합니다. 접근자 프로퍼티는 객체의 프로퍼치 종류 중 새로운 종류의 프로퍼티로 함수처럼 정의되며 호출은 데이터 프로퍼티에 접근하는 것처럼 호출할 수 있습니다. 함수 앞에 `get`, `set` 키워드가 붙으면 해당 함수는 접근자 프로퍼티로 동작한다는 특징이 있습니다.

<br>

3. 객체 변경을 방지하는 메소드들에 대해 설명해주세요.

- 객체 변경을 방지하는 메소드로는 확장을 금지하는 Object.preventExtensions, 객체를 밀봉하는 Object.seal, 객체를 동결하는 Object.freeze가 있습니다. 이 메소드들은 객체의 변경을 방지하는 강도가 다른데, preventExtensions은 프로퍼티 추가가 금지되며 확장이 가능한 객체인지 여부는 isExtensible 메소드로 확인할 수 있습니다. seal 메소드는 객체를 읽기와 쓰기만 가능하게 하는 메소드로 isSealed 메소드로 밀봉 객체 여부를 확인할 수 있습니다. freeze 메소드는 객체를 읽기만 가능하도록 만들며 isFrozen 메소드로 확인할 수 있습니다.

<br>

4. 자바스크립트는 내부 슬롯과 내부 메서드를 통해 접근이 가능한지에 대해 설명해주세요.

- 내부 슬롯과 내부 메소드는 ECMAScript 사양에 정의된 대로 구현되어 자바스크립트 엔진에서 실제로 동작하지만 개발자가 직접 접근할 수 있도록 외부로 공개된 객체의 프로퍼티는 아니기 때문에 직접적으로 접근하는 것은 불가능하지만 `__proto__`, `Object.getOwnPropertyDescriptor` 등의 메소드로 간접적으로 접근하는 것은 가능합니다.

<br>

5. 프로퍼티가 생성될 때 어떠한 것들을 정의하나요?

- 자바스트립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 정의하는데, 이 때 프로퍼티의 상태란 프로퍼티의 값, 값의 갱신 여부, 열거 가능 여부, 정의 가능 여부를 의미합니다.

<hr>

### 17. 생성자 함수에 의한 객체 생성

<br>

1. 클래스와 생성자 함수의 차이점은 무엇인가요?

- 생성자 함수는 new 연산자와 함께 호출되어 객체를 생성하는 함수를 의미하는데, new 키워드를 생략하고 호출할 경우 일반 함수로 호출되지만 클래스는 new 키워드 없이 호출할 경우 타입 에러가 발생합니다. 또한 생성자 함수는 호이스팅이 발생하지만 클래스는 let, const 키워드와 비슷하게 호이스팅이 발생하지 않는 것처럼 동작한다는 차이점이 있습니다.

<br>

2. 객체를 생성하는 방식과 방식에 대한 문제점과 장점에 대해 설명해주세요.

- 객체를 생성하는 방식에서는 Object 생성자 함수를 사용하는 방식과 객체 리터럴을 사용하는 방식이 있습니다. 객체 리터럴을 사용하면 직관적이고 간편하다는 장점이 있지만 하나의 객체만 생성 가능하기 때문에 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우에도 매번 같은 프로퍼티을 기술해야 합니다. 생성자 함수는 객체를 생성하기 위한 템플릿 형태로 사용하여 프로퍼티 구조가 동일한 객체를 여러 개 생성할 때에도 간편하게 사용 가능합니다.

<br>

3. constructor와 non-constructor 함수 객체의 차이점에 대해 설명해주세요.

- 자바스크립트에서는 함수 정의 방식에 따라 constructor와 non-constructor를 구분합니다. 함수 선언문과 함수 표현식으로 정의된 함수만이 constructor이며, ES6의 화살표 함수와 메소드 축약 표현으로 정의된 함수는 non-constructor로 구분합니다.

<br>

4. 생성자 함수의 인스턴스 생성 과정을 설명해주세요.

- new 연산자와 함께 생성자 함수를 호출하면 자바스크립트 엔진은 암묵적으로 빈 객체를 생성합니다. 이 때, 빈 객체는 생성자 함수가 생성한 인스턴스이며, 이는 this에 바인딩됩니다. 그리고 생성자 함수의 코드를 한 줄씩 실행하며 this에 바인딩되어 있는 인스턴스에 프로퍼티나 메소드를 추가하고 생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값을 할당합니다. 셍상지 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환되며 return 문이 있을 경우 return 문에 명시된 객체가 반환됩니다

<br>

5. 생성자 함수의 this 는 무엇을 의미하나요?

- new 키워드를 사용하여 생성자 함수를 호출할 경우 이 때 this는 만들어질 객체를 참조합니다. 만약 new 키워드 없이 호출했다면 this를 호출된 컨텍스트를 가리키게 됩니다.

<hr>

### 18. 함수와 일급 객체

<br>

1. 순수함수란 무엇이며, 일반함수와의 차이점은 무엇인가요?

- 순수함수란 외부 상태에 의존하거나 변경하지 않으며 부수 효과가 없는 함수이며 매개변수를 통해 함수 내부로 전달된 인수에게만 의존해 반환값을 만든다면 순수함수가 아닌 일반 함수는 외부상태에 의존하거나 외부상태를 변경하는 함수입니다.

<br>

2. 유사 배열 객체와 이터러블의 차이점에 대해 설명해주세요.

- 유사 뱌열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고, length 프로퍼티를 갖는 객체를 의미하며, 순회 가능하지만 push, pop, map과 같은 메소드 사용은 불가능합니다. 이터러블 객체는 `for of`문으로 순회 가능하며 스프레드 문법, 배열 디스트럭처링 대상으로 사용 가능합니다.

<br>

3. 일급 객체의 조건에 대해 설명해주세요.

- 일급 객체는 변수나 자료구조에 담을 수 있어야 하며, 함수의 매개변수로 전달 가능하며 함수의 반환값으로 사용할 수 있어야 합니다.

<br>

4. arguments 프로퍼티에 대해 설명해주세요.

- arguments 프로퍼티는 함수 호출 시 전달된 인수들의 정보를 담고 있는 순회 가능한 유사 배열 객체이며, 함수 내부에서 지역 변수처럼 사용되는 프로퍼티입니다. arguments 객체는 인수를 프로퍼티 값으로 소유하며, 프로퍼티 키는 인수의 순서를 나타냅니다. arguments 객체 내부의 callee 프로퍼티는 arguments 객체를 생성한 함수를 가리키며, length 프로퍼티는 인수의 개수를 가리키기 때문에 arguments 객체의 length 프로퍼티를 사용하면 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용합니다.

<br>

5. name 프로퍼티는 ES5 와 ES6 에서 어떤식으로 동작을 하나요?

- 익명 함수 표현식의 경우, ES5에서 name 프로퍼티는 빈 문자열을 값으로 가지지만 ES6에서는 함수 객체를 가리키는 식별자를 값으로 가집니다.
