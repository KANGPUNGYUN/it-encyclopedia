## 딥다이브 14장 - 19장

<hr>

### 14. 전역 변수의 문제점

<br>

1. 전역 변수 사용을 억제하는 방법에는 무엇이 있는가?

- 크게 즉시 실행 함수, 네임스페이스 객체, 모듈 패턴, ES6 모듈을 활용하여 전역 변수 사용을 억제할 수 있습니다.

즉시 실행 함수 방법은 즉시 실행 함수로 감싼 모든 변수는 즉시 실행 함수의 지역변수로 변경할 수 있습니다.

네임스페이스 객체 방법은 전역에 네임 스페이스 역할을 담당할 객체를 생성하고 전역변수처럼 사용하고 싶은 변수를 프로퍼티로 추가해 식별자 충돌을 방지합니다.

모듈 패턴은 최근에 추가된 private라는 접근 제한자를 통해 외부에서 접근 불가능한 변수나 함수를 생성합니다.

ES6 모듈을 사용하면 더는 전역변수를 사용할 수 없도록 제한합니다. ES6 모듈에서 파일 자체의 독자적인 모듈 스코프를 제공합니다.

<br>

2. 변수의 생명 주기에 대해 설명해주세요

- 변수는 선언에 의해 생성되고 할당을 통해 값을 갖습니다. 그리고 언젠가 소멸하게 되는데 이렁게 변수가 생성되고 소멸하기까지의 과정을 변수의 생명주기라고 합니다. 그리고 지역변수와 전역변수에 따라 변수의 생명주기가 다릅니다. 지역 변수의 생명주기는 함수의 생명주기와 일치하며전역 변수의 생명 주기는 전역 객체의 생명주기와 일치합니다.

<br>

3. 전역 변수의 문제점에 대해 설명해주세요

- 전역 변수의 문제점으로 암묵적 결합, 긴 생명 주기, 스코프 체인 상에서 종점에 존재하는 문제, 네임 스페이스 오염 등이 있다.

암묵적 결합이란 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용하여 의도치 않게 상태가 변경될 수 있는 위험성이 높아지는 현상을 의미합니다.

전역 변수는 긴 생명 주기를 가지는데, 이는 상태 변경에 의한 오류가 발생할 확률이 큰 원인이기도 합니다.

전역 변수는 스코프 체인 상 종점에 존재하기 때문에 변수를 검색할 때의 가장 마지막에 검색되기 때문에 검색 속도가 느릴 수 밖에 없습니다.

자바스크립트는 파일이 분리되어 있다 하더라도 하나의 전역 스코프를 공유하기 때문에 다른 파일 내에서 동일 한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있습니다.

<br>

4. 전역 변수를 반드시 사용해야 할 경우에 대해 설명해주세요

- 함수가 종료되어도 해당 변수가 소멸되지 않고 계속해서 메모리에 저장되어 있도록 누적되어야 하는 상황에 전역 변수를 사용합니다.

<br>

5. 네임스페이스에 대해 설명해주세요

- 네임스페이스란 개체를 구분할 수 있는 범위를 나타내는 말로, 하나의 이름 공간에서는 하나의 이름이 단 하나의 개체만을 가리키게 됩니다. 즉 같은 이름이라도 소속된 네임 스페이스가 다르면 다른 이름으로 취급하게 되어 있는 범위를 의미합니다.

<hr>

### 15. let, const 키워드와 블록 레벨 스코프

<br>

1. var 키워드로 선언한 전역 변수와 let 키워드로 선언한 전역 변수의 차이를 설명해주세요.

- var 키워드로 선언한 전역 변수는 중복 선언이 가능하며, 함수 레벨 스코프를 가지기 때문에 함수 외부에서 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 됩니다. let 키워드로 선언한 전역 변수는 중복 선언은 문법 에러가 발생하고, 블록 레벨 스코프를 가지기 때문에 변수 선언이 코드 블록 안에서만 유효합니다.

<br>

2. var보다 let, const 사용을 권장하는 이유를 설명해주세요.

- var는 변수 중복 선언을 허용하여 이미 선언되어 있는 것을 모르고 동일한 이름의 변수가 중복 선언을 하면서 값을 할당했다면 의도치 않게 먼저 선언된 변수 값이 변경되는 부작용이 있습니다. 또한 변수 호이스팅에 의해 에러를 발생시키지 않지만 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남기기 때문에 let, const을 사용하여 var의 문제를 보완합니다.

<br>

3. 일시적 사각지대(Temporal Dead Zone; TDZ)와 TDZ의 영향을 받는 구문들에 대해 설명해주세요.

- 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 일시적 사각지대(Temporal Dead Zone; TDZ)라고 부릅니다. TDZ의 영향을 받는 구문들로는 const 변수와 let 변수, class 구문, constructor 함수 내부의 super 메서드, 기본 함수 매개변수가 있습니다.

<br>

4. const 키워드로 선언한 값을 변경할 수 있는 방법에 대해 설명해주세요

- 기본적으로 const 키워드로 선언한 변수는 재할당이 금지되지만, const 키워드로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 있습니다. 변경 불가능한 값인 원시 값은 재할당 없이 변경할 수 없지만 변경 가능한 값인 객체는 재할당 없이도 직접 변경이 가능하기 때문입니다. 이때 객체가 변경되더라도 변수에 할당된 참조값은 변경되지 않습니다.

<br>

5. 클로저는 어떤 문제를 회피하기 위해 사용하는 방법인지 스코프를 들어 설명해주세요

- 클로저는 상태가 의도적으로 변경되지 않게 상태를 안전하게 은닉하고 특정 함수에게만 상태변경을 허용하기 위해 사용하는 방법입니다. 자바스크립트는 기본적으로 함수를 어디서 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정하는 렉시컬 스코프 환경을 가집니다. 클로저는 함수가 선언된 렉시컬 스코프를 기억하여 함수가 스코프 밖에서 실행되었을 때에도 이 스코프에 접근이 가능하게 하는 기술을 말합니다.

<hr>

### 16. 프로퍼티 어트리뷰트

<br>

1. attribute와 property의 차이점은 무엇인가요?

- 자바스크립트에서 property는 키와 값으로 구성된 것으로 객체는 프로퍼티의 집합입니다. attribute란 프로퍼티의 상태를 의미하며, 프로퍼티의 상태란 프로퍼티의 값, 값의 갱신 가능 여부, 열거 가능 여부, 재정의 가능 여부를 의미합니다.

<br>

2. 데이터 프로퍼티와 접근자 프로퍼티에 대해 설명해주세요.

- 데이터 프로퍼티는 키와 값으로 구성된 일반적인 프로퍼티입니다. 전근자 프로퍼티는 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티입니다.

<br>

3. 객체 변경을 방지하는 메소드들에 대해 설명해주세요.

- 객체 변경을 방지하는 메소드들로 객체 확장 금지(Object.preventExtensions)와 객체 밀봉(Object.seal), 객체 동결(Object.freeze)이 있습니다.

객체 확장 금지 메서드는 프로퍼티 추가를 금지하고 프로퍼티의 삭제, 값 읽기, 쓰기, 프로퍼티 어트리뷰트 재정의가 가능합니다.

객체 밀봉 메서드는 프로퍼티 추가와 삭제 프로퍼티 어트리뷰트 재정의를 금지하지만, 프로퍼티 값 읽기와 쓰기는 가능한 메서드입니다.

객체 동결 메서드는 프로퍼티 값 읽기를 제외한 프로퍼티의 모든 변경을 금지하는 메서드입니다.

<br>

4. 자바스크립트는 내부 슬롯과 내부 메서드를 통해 접근이 가능한지에 대해 설명해주세요.

- 내부 슬롯은 자바스크립트 엔진의 내부 로직이므로 원칙적으로 직접 접근할 수 없지만 `[[prototype]]` 내부 슬롯의 경우, `__proto__`를 통해 간접적으로 접근할 수 있습니다

<br>

5. 프로퍼티가 생성될 때 어떠한 것들을 정의하나요?

- 프로퍼티를 생성하면 프로퍼티 어트리뷰트를 명시적으로 정의하거나 기존 프로퍼티 어트리뷰트를 재정의하는 것을 의미합니다. 즉, 프로퍼티 값을 갱신 가능하도록 할 것인지, 프로퍼티를 열거 가능하도록 할 것인지, 프로퍼티를 재정의 가능하도록 할 것인지를 정의할 수 있습니다.

<hr>

### 17. 생성자 함수에 의한 객체 생성

<br>

1. 클래스와 생성자 함수의 차이점은 무엇인가요?

- 생성자 함수는 new 연산자와 함께 호출하여 객체를 생성하는 함수를 말합니다. 클래스도 마찬가지로 new 연산자와 함께 호출하여 객체를 생성합니다. 다만 생성자 함수는 new 연산자를 생략하면 생성자 함수는 일반 함수로 호출되고 클래스는 타입 에러가 발생합니다. 또 둘 다 상속이란 개념이 존재하지만, 생성자 함수는 프로토타입의 체인에서 인스턴스가 프로토타입의 프로퍼티를 상속받는거고 클래스는 extends 키워드를 통해 클래스 상속에 의해 확장되는 개념입니다.

<br>

2. 객체를 생성하는 방식과 방식에 대한 문제점과 장점에 대해 설명해주세요.

- 객체를 생성하는 방식에는 객체 리터럴에 의한 객체 생성방식과 생성자 함수에 의한 객체 생성방식이 있습니다. 객체 리터럴에 의한 객체 생성방식은 직좐적이고 간편하지만, 단 하나의 객체만 생성하기 때문에 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 할 경우 매번 같은 프로퍼티를 기술해야 되기 때문에 비효율적입니다. 반면에 생성자 함수에 의한 객체 생성방식은 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있습니다.

<br>

3. constructor와 non-constructor 함수 객체의 차이점에 대해 설명해주세요.

- 자바스크립트 엔진은 함수 정의를 평가하여 함수 객체를 생성할 때 함수 정의 방식에 따라 constructor와 non-constructor로 구분합니다. 일반 함수 또는 생성자 함수로써 호출할 수 있는 객체를 constructor라 하고, 일반 함수로서만 호출할 수 있는 객체를 non-constructor라고 합니다. constructor에는 함수 선언문, 함수 표현식, 클래스가 포함되며, non-constructor는 메서드와 화살표 함수가 포함됩니다.

<br>

4. 생성자 함수의 인스턴스 생성 과정을 설명해주세요.

- 생성자 함수를 동작하면 암묵적으로 빈 객체가 생성이 됩니다. 이 빈 객체를 생성자 함수가 생성한 인스턴스이고 이 인스턴스는 this에 바인딩됩니다. 그리고 생성자 함수에 기술 되어있는 코드가 한 줄씩 실행되어 this에 바인딩되어있는 인스턴스를 초기화합니다. 생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환됩니다. 만약 this가 아닌 다른 객체를 명시적으로 반환하면 this가 반환되지 못하고 return문에 명시한 객체가 반환됩니다. 하지만 명시적으로 원시값을 반환하면 원시값 반환은 무시되고 암묵적으로 this가 반환됩니다.

<br>

5. 생성자 함수의 this 는 무엇을 의미하나요?

- 생성자 함수의 this는 생성자 함수가 생성한 인스턴스를 의미합니다.

<hr>

### 18. 함수와 일급 객체

<br>

1. 순수함수란 무엇이며, 일반함수와의 차이점은 무엇인가요?

- 순수함수란 동일한 인자가 주어졌을 때 항상 같은 값을 리턴하는 함수를 의미합니다. 같은 의미로 부수효과가 없는 함수를 뜻합니다. 여기서 부수효과란 리턴 값으로 결과를 만드는 것 이외에 들어온 인자를 직접 변경하는 등 외부에 영향을 주는 효과를 의미합니다.

일반함수에는 변수도 포함하여 외부 상태에 영향을 미치는 부수효과가 영향을 미치는 경우도 포함하기 때문에 순수함수와 차이가 있습니다.

<br>

2. 유사 배열 객체와 이터러블의 차이점에 대해 설명해주세요.

- 유사 배열 객체는배열처럼 인덱스로 프로퍼티 값에 접근할 수 있으며, length 프로퍼티를 갖는 객체를 말합니다. 이터러블은 ES6에서 도입된 이터레이션 프로토콜을 준수하면서 순회가능한 자료구조를 의미합니다. 이터러블이라는 개념을 사용하면 어떤 객체이든 `for..of` 반복문을 적용할 수 있지만 유사뱌열은 이터러블이 아닌 일반 객체이기 때문에 `for..of` 반복문으로 순회할 수 없습니다.

<br>

3. 일급 객체의 조건에 대해 설명해주세요.

- 무명의 리터럴로 생성이 가능하고, 변수나 자료구조에 저장할 수 있으며, 함수의 매개변수에 전달할 수 있고, 함수의 반환값으로 사용할 수 있는 조건을 모두 만족하는 객체를 일급객체라 합니다.

<br>

4. arguments 프로퍼티에 대해 설명해주세요.

- 함수 객체의 arguments 프로퍼티는 arguments 객체입니다. arguments 객체는 함수 호출 시 전달된 인수들의 정보를 담고 있는 순회 가능한 유사 배열 객체이며, 함수 내부에서 지역 변수처럼 사용됩니다. 즉, 함수 외부에서 참조할 수 없는 객체입니다.

<br>

5. name 프로퍼티는 ES5 와 ES6 에서 어떤식으로 동작을 하나요?

- 익명 함수 표현식의 경우 ES5에서 name 프로퍼티는 빈 문자열 값으로 가지지만, ES6에서는 함수 객체를 가리키는 식별자를 값으로 갖습니다.
