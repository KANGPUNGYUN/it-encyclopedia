## 딥다이브 14장 - 19장

<hr>

### 14. 전역 변수의 문제점

<br>

1. 전역 변수 사용을 억제하는 방법에는 무엇이 있는가?

- 지역 변수 사용하기
- 즉시 실행 함수
  - 즉시 실행 함수는 함수 정의와 동시에 단 한번만 호출이 된다. 때문에 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.
- 네임스페이스 객체
  - 객체 리터럴 네임스페이스를 통해서 하나의 전역 객체를 생성한 후, 모든 함수 또는 객체, 변수를 이곳에 추가하는 방식으로 사용한다. 이는 코드 내에서 뿐만 아니라 같은 페이지에 존재하는 JS 라이브러리, 서드 파티 코드와의 이름 충돌을 방지해주며 체계적인 장점을 가지고 있다.
- 모듈 패턴
  - 모듈 패턴은 클래스를 모방해서 관련이 있는 변수, 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈로 만드는 것을 말한다.
  - 이러한 모듈 패턴은 클로저 기반을 동작하며, 모듈 패턴의 가장 큰 특징은 전역 변수의 억제 말고도 캡슐화도 구현이 가능한다.
- ES6 모듈
  - ES6 모듈을 사용하면 ES6 모듈이 파일 자체의 독자적인 모듈 스코프를 제공하기 때문에 더이상 전역 변수를 사용할 수 없게 만든다.
  - 모듈 내에서 var 키워드로 선언한 변수는 더는 전역 변수가 아니며 window 객체의 프로퍼티도 아니게 된다.

<br>

2. 변수의 생명 주기에 대해 설명해주세요.

- 변수는 런타임 이전에 선언에 의해 생성되고, 런타임 시점에 할당을 통해 값을 가지며, 사용되지 않으면 언젠가 가비지컬렉터로 이동하게 되어 소멸하게 된다.

- 지역 변수의 생명주기

  - 변수는 자신이 선언된 위치에서 생성되고 소멸한다.
  - 함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸한다.(지역 변수의 생명주기 == 함수의 생명주기)
  - 메모리 공간이 확보된 시점에서 메모리 공간이 해제되어 가용 메모리 풀에 반환되는 시점까지이다.

- 전역 변수의 생명주기
  - var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다.

<br>

3. 전역 변수의 문제점에 대해 설명해주세요.

- 암묵적 결합
  - 암묵적 결합은 모든 코드가 전역 변수를 참조하고 변경할 수 있게 허용하는 것을 의미하며, 변수의 유효 범위가 크면 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성이 높아진다.
- 긴 생명주기
  - 생명주기가 길기 때문에 메모리 리소스를 오랜 기간 소비하고, 전역 변수의 상태를 변경할 수 있는 시간도 길고 기회도 많다.
  - var 키워드는 변수의 중복 선언을 허용하기 때문에 생명 주기가 긴 전역 변수는 변수 이름이 중복될 가능성이 있으며 의도치 않은 재할당이 이뤄지기도 한다.
- 스코프 체인 상에서 종점에 존재
  - 변수 검색 시, 전역 변수의 검색 속도가 가장 느리기 때문에 가장 마지막에 검색된다.
- 네임스페이스 오염
  - 자바스크립트는 파일이 분리되어 있어도 하나의 전역 스코프를 공유한다. 때문에 다른 파일 내에서 동일한 이름으로 선언된 전역 변수나 전역 함수가 같은 스코프에 존재할 경우 예상치 못한 결과를 가져올 수 있다.

<br>

4. 전역 변수를 반드시 사용해야 할 경우에 대해 설명해주세요.

- 전역 변수를 선언한 의도는 코드 어디서든 참조하고 할당할 수 있는 변수를 사용하겠다는 것이다.
- 불가피하게 전역 변수를 사용해야 하는 경우에는 네임스페이스 객체 리터럴을 사용하여 하나의 객체를 전역 변수로 만들고, 객체의 속성으로 변수를 관리하는 방법을 사용하기를 권장한다.
- ES6에서 let과 const 변수 선언 키워드가 도입되기 이전에는 전역 변수 선언 키워드인 var 만이 존재했기 때문이다.

<br>

5. 네임스페이스에 대해 설명해주세요.

- 네임스페이스는 객체나 변수가 겹치지 않는 안전한 소스 코드를 만드는 개념으로,
  가장 기본적인 네임스페이스 패턴으로는 객체 리터럴 네임스페이스 방식이 있다.
  하나의 전역 객체를 생성한 후, 모든 함수 또는 객체, 변수를 이곳에 추가하는 방식으로 사용한다.

<hr>

### 15. let, const 키워드와 블록 레벨 스코프

<br>

1. var 키워드로 선언한 전역 변수와 let 키워드로 선언한 전역 변수의 차이를 설명해주세요.

- var 키워드

  - 같은 스코프 내에서 변수 중복 선언 허용된다.
  - 함수의 코드 블록만을 지역 스코프로 인정하는 함수 레벨 스코프이기 때문에 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.
  - 변수 선언문 이전에 참조 가능하며 에러를 발생하지 않는다.

- let 키워드

  - 같은 스코프 내에서 변수 중복 선언 허용하지 않는다.
  - 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프이다.
  - 변수 선언문 이전에 참조하면 참조 에러가 발생한다.

<br>

2. var보다 let, const 사용을 권장하는 이유를 설명해주세요.

- var 키워드로 선언된 변수는 같은 스코프 내에서 변수 중복선언 허용하며,
  함수 레벨 스코프이기 때문에 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.
  게다가 변수 선언 시, 선언문 이전에 참조가 가능하기 때문에 에러가 발생하지 않고,
  할당문 이전에 변수를 참조하면 undefined를 반환하기 때문에 예기치 못한 에러를 발생할 가능성이 크다.
  하지만 let이나 const 키워드는 같은 스코프 내에서 중복 선언을 허용하지 않기 때문에 var로 선언했을 때와 달리 문법 에러를 발생시킨다.

<br>

3. 일시적 사각지대(Temporal Dead Zone; TDZ)와 TDZ의 영향을 받는 구문들에 대해 설명해주세요.

- 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 일시적 사각지대라고 부른다.
  let과 const 키워드로 선언한 변수가 이 TDZ에 영향을 받게 된다.
- 식별자의 선언 단계는 런타임 이전에 이루어지고, 초기화 단계는 변수 선언문에 도달했을 때 실행되며,
  값의 할당은 런타임 시점에 이루어지는데, 선언과 초기화 단계가 각각 따로 이루어져있는 let과 const 키워드로 선언한 변수는
  변수 선언문 이전에 값에 접근하려고 하면 선언 단게만 이루어지고, 초기화 단계가 이루어지지 않은 상태이기 때문에 참조 에러가 발생한다.

<br>

4. const 키워드로 선언한 값을 변경할 수 있는 방법에 대해 설명해주세요.

- const 키워드는 재할당이 금지되었을 뿐이지 불변을 의미하지 않기 때문에,
  const 키워드로 선언된 변수에 변경가능한 값인 객체를 할당하면 값을 변경할 수 있게 된다.

<br>

5. 클로저는 어떤 문제를 회피하기 위해 사용하는 방법인지 스코프를 들어 설명해주세요.

-

<hr>

### 16. 프로퍼티 어트리뷰트

<br>

1. attribute와 property의 차이점은 무엇인가요?

- attribute

  - HTML 마크업에 정의되어 있는 것으로 HTML요소의 추가적인 정보를 전달하고 `key=’value’` 형태로 작성한다.
  - attribute는 default 값이 변하지 않는다.(→ 정적)
  - elements에 추가적인 정보를 넣을 때 사용되는 요소이다.
  - attribute는 html document/file 안에서 존재한다.

- property

  - HTML DOM tree에 있는 것이다.
  - default 값이 변할 수 있다.(→ 동적)
  - property는 html DOM tree 안에서 attribute를 가리키는 표현이다.

  <br>

2. 데이터 프로퍼티와 접근자 프로퍼티에 대해 설명해주세요.

- 데이터 프로퍼티

  - 키와 값으로 구성된 일반적인 프로퍼티이다.
  - 지금까지 살펴본 모든 프로퍼티는 데이터 프로퍼티이다.
  - 프로퍼티 어트리뷰트는 JS엔진이 프로퍼티를 생성할 때, 기본값으로 자동 정의된다.

  ```javascript
  person.name; // minzyee
  person.age; // 27
  ```

- 접근자 프로퍼티
  - 접근자 프로퍼티는 자체적으로는 값을 갖지 않고, 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용(호출되는)하는 접근자 함수로 구성된 프로퍼티이다.
  - 접근자 함수는 `getter / setter` 함수라고도 부른다.
  - 접근자 프로퍼티는 getter와 setter 함수를 모두 정의할 수도 있고 하나만 정의할 수도 있다.
  ```javascript
  person.name; // minzyee
  person.age; // 27
  ```

<br>

3. 객체 변경을 방지하는 메소드들에 대해 설명해주세요.

- Object.preventExtensions: 객체의 확장을 금지. 즉, 프로퍼티 추가 금지이다.
  Object.isExtensible 메서드로 확인가능하다.
- Object.seal: 객체 밀봉을 의미하며, 프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지를 의미한다.
  밀봉된 객체는 읽기와 쓰기만 가능하다. Object.isSealed 메서드로 확인가능하다.
- Object.freeze: 객체의 동결을 의미하며, 프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지,
  프로퍼티 값 갱신 금지를 의미한다. 동결된 객체는 읽기만 가능하다.
  Object.isFrozen 메서드로 확인가능하다.

<br>

4. 자바스크립트는 내부 슬롯과 내부 메서드를 통해 접근이 가능한지에 대해 설명해주세요.

- 내부 슬롯과 내부 메서드는 ECMAScript 사양에 정의된 대로 구현되어 JS엔진에서 실제로 동작하지만,
  개발자가 직접적으로 접근할 수 있도록 외부로 공개된 객체의 프로퍼티는 아니다.
- 내부 슬롯과 내부 메서드는 자바스크립트 엔진의 내부 로직이기 때문에 원칙적으로 직접 접근하거나 호출할 수 있는 방법을 제공하지는 않지만, 일부 내부 슬롯과 내부 메서드에 한해 간접적으로 접근할 수 있는 수단을 제공하는데 모든 객체가 갖고있는 [[Prototype]] 라는 내부 슬롯에 **proto** 를 통해서 간접적으로 접근이 가능하다.

<br>

5. 프로퍼티가 생성될 때 어떠한 것들을 정의하나요?

- 프로퍼티 어트리뷰트에는 [[Value]], [[Writable]], [[Enumerable]], [[Configurable]]가 정의된다.

<hr>

### 17. 생성자 함수에 의한 객체 생성

<br>

1. 클래스와 생성자 함수의 차이점은 무엇인가요?

- 클래스: new 키워드가 필수이며, 생략되면 타입에러가 발생한다. extends 키워드로 클래스 상속에 의한 확장이 가능하다.
- 생성자 함수: new 키워드 생략되면 일반 함수로 호출한다. 프로토타입 체인을 통해 상속 받는다.

<br>

2. 객체를 생성하는 방식과 방식에 대한 문제점과 장점에 대해 설명해주세요.

- 둘 다 new 연산자를 사용하여 객체를 생성해야한다.
  만약 new 연산자를 생략하게 되면, 생성자 함수는 일반 함수로 호출되고, 클래스는 타입 에러가 발생한다.

<br>

3. constructor와 non-constructor 함수 객체의 차이점에 대해 설명해주세요.

- 자바스크립트 엔진은 함수 정의를 평가하여 함수 객체를 생성할 때 함수의 정의 방식에 따라 함수를 constructor와 non-constructor로 구분한다.
  - constructor 함수 : 함수 선언문, 함수 표현식, 클래스
  - non-constructor 함수 : 메서드(ES6 메서드 축약 표현), 화살표 함수

<br>

4. 생성자 함수의 인스턴스 생성 과정을 설명해주세요.

- new 연산자와 함께 생성자 함수를 호출하면 JS엔진은 암묵적으로 인스턴스(빈 객체)를 생성하고,
  인스턴스를 초기화한 후 암묵적으로 인스턴스를 반환한다. 암묵적으로 생성된 빈 객체, 즉 인스턴스는 this에 바인딩 된다.
  생성자 함수 내부의 this가 생성자 함수가 생성할 인스턴스를 가리키는 이유는

<br>

5. 생성자 함수의 this 는 무엇을 의미하나요?

- 암묵적으로 빈 객체가 생성되고, 이 빈 객체가 바로 생성자 함수가 생성한 인스턴스이다.
  그리고 인스턴스는 this에 바인딩된다. 생성자 함수 내부의 this가 생성자 함수가 생성할 인스턴스를 가리키는 이유가 바로 이것이다.
  이 처리는 생성자 함수 몸체의 코드가 한 줄씩 실행되는 런타임 이전에 실행된다.
  this에 바인딩 되어 있는 인스턴스에 프로퍼티나 메서드를 추가하고 생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여
  초기화하거나 고정값을 할당한다.

<hr>

### 18. 함수와 일급 객체

<br>

1. 순수함수란 무엇이며, 일반함수와의 차이점은 무엇인가요?

- 순수함수
  - 같은 입력에 대해서 같은 결과를 return하는 함수
  - 함수의 바깥 영역에 side effect를 초래하지 않는 함수
    (함수 외부의 데이터나 함수에 전달된 데이터를 변경하지 않는 함수)
  - 예측이 가능하여 이해하기 쉽다.
- 일반함수
  - side effect를 초래할 가능성이 있다.
  - 항상 동일한 출력을 반환하지 않을 수 있다.
  - 예측이 가능하지 않다.

<br>

2. 유사 배열 객체와 이터러블의 차이점에 대해 설명해주세요.

- 유사 배열 객체:
  - 배열처럼 인덱스로 접근할 수 있는 길이 속성과 요소를 가진 객체이다.
  - 실제 배열이 아니며 배열의 모든 메서드와 속성을 가지고 있는 것은 아닙니다.
- 이터러블
  - 이터블 인터페이스를 구현하는 개체로 for...of 루프 또는 Array.from() 메서드와 함께 사용할 수 있습니다.
  - 배열과 문자열은 모두 자바스크립트에서 반복 가능하다.

<br>

3. 일급 객체의 조건에 대해 설명해주세요.

- 무명의 리터럴로 생성할 수 있고, 런타임에 생성이 가능하다.
- 변수나 자료구조에 저장할 수 있다.
- 함수의 매개변수에 전달할 수 있다.
- 함수의 반환값으로 사용할 수 있다.

<br>

4. arguments 프로퍼티에 대해 설명해주세요.

- 함수 호출 시 전달되는 인수들의 정보를 담고 있는 배열이다. 함수 안에서만 사용 가능한 지역변수이다.
- arguments 객체를 사용해 함수 내에서 모든 인수를 참조 가능한다.
- 호출할 때 제공한 인수 각각에 대한 항목을 갖고 있으며, 항목의 인덱스는 0부터 시작한다.
- 정의된 인자보다 적게 함수를 호출한 경우, 넘겨주지 않은 인자에는 undefined 할당하며,
  정의된 인자보다 많게 함수를 호출한 경우, 에러가 발생하지 않고, 초과된 인수는 무시된다.
- 대표적인 속성으로는 현재 실행중인 함수를 호출한 함수를 가리키는 arguments.caller 가 있으며, 함수에 전달된 인수의 수를 가리키는 arguments.length 속성이 있다.

<br>

5. name 프로퍼티는 ES5 와 ES6 에서 어떤식으로 동작을 하나요?

- 함수 객체의 name 프로퍼티는 함수 이름을 나타내는데, ES5 와 ES6에서 서로 다르게 동작한다.
- 익명 함수 표현식의 경우 ES5에서 name 프로퍼티는 빈 문자열을 값으로 갖지만, ES6에서는 함수 객체를 가리키는 식별자를 값으로 갖는다.
