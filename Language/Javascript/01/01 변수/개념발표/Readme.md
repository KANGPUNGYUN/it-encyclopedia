# 자바스크립트 딥다이브 개념 발표

## 01. 변수

### :one: 변수는 왜 등장했을까?

- 메모리 주소를 통해 값에 직접적으로 접근하는 것은 오류를 발생시킬 확률이 높은 행위이다. 따라서 자바스크립트는 개발자가 직접적으로 메모리를 제어하는것을 허용하지 않는다.

- 값이 저장될 메모리의 주소는 코드가 실행될 때의 메모리 상태에 따라 임의로 정해진다. 그러므로 동일한 컴퓨터의 동일한 코드를 실행한다고 하더라도 코드가 실행될 때마다 값이 저장될 메모리 주소는 변경된다. 이와 같이 코드가 실행되기 전에는 값이 저장된 메모리 주소를 알기가 어렵다. 따라서 메모리에 직접적으로 접근하는 것은 올바른 행위가 아니다.

- 이러한 문제점에 대한 완충작용으로서 프로그래밍 언어는 `변수`를 제공한다. 변수는 기억하고 싶은 값을 메모리에 저장하고 저장된 값을 읽어 들여서 재사용할 수 있게 만들어준다.

<br>

### :two: 그래서 변수가 뭔데?

- `변수`

  - 하나의 값을 저장하기 위해 확보한 메모리 공간
  - [프로그래밍 언어상] 하나의 값을 저장하고 참조하는 메커니즘 (배열/객체를 사용하면 관련된 여러개의 값을 그룹화해서 하나의 값처럼 사용할 수 있음)

  ```js
  /* 변수에는 하나의 값만 저장가능 */
  var userId = "danny0125";
  var userName = "kim";

  /* 배열/객체를 사용해서 여러 개의 값을 그룹화해서 하나의 값처럼 사용할 수 있음 */
  var userInfo = { id: "danny0125", name: "kim" };
  var usersInfo = { id: "danny0125", name: "kim" }, {id: "daniel", name:"lee"};
  ```

<br>

- `변수명`

  - 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름
  - 해당 메모리 공간을 식별하기 위해 붙인 이름
  - 값의 위치를 가리키는 상징적인 명칭

<br>

- `변수값`

  - 변수에 저장된 값

<br>

- `할당 (assignment)`

  - 변수에 값을 저장하는 것
  - 대입, 저장

<br>

- `참조 (reference)`

  - 변수에 저장된 값을 읽어 들이는 것
  - 변수명을 이용하여 참조 요청시 자바스크립트 엔진은 변수명과 매핑된(짝이 지어진) 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환함

    ```js
    var result = 10 + 20;
    result; // 30. 변수명을 이용한 참조 -> 메모리 상에 저장된 값을 반환
    ```

<br>

### :three: 변수의 작동원리

- 변수는 프로그래밍 언어의 컴파일러(또는 인터프리터)에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행된다.
- 따라서 개발자가 직접 메모리 주소를 통해 값을 저장하고 참조할 필요가 없고 변수를 통해 안전하게 값에 접근할 수 있다.

<br>

### :four: 식별자 (identifier)

#### 식별자란?

- 어떤 값을 구별하여 식별할 수 있는 고유한 변수명을 뜻함
- 코드 내의 변수/함수/속성 등을 구별하는 문자열임
- 메모리 상에 존재하는 어떤 값을 식별할 수 있는 모든 이름을 `식별자`라고 함

  - ex) 변수, 함수, 클래스

<br>

#### 식별자의 특징

- 값은 메모리 공간에 저장되어 있다. 따라서 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해 낼 수 있어야 한다. 이를 위해 식별자는 어떤 값이 저장되어 있는 메모리 주소를 기억(저장)해야 한다. (식별자는 값을 저장하는것이 아니다 !)

- 식별자는 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑정보는 메모리에 저장되어야 한다.

- 식별자로 값을 구분해서 식별하겠다는 것은 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 의미이다.

- 즉, 식별자는 메모리 주소에 붙인 이름이라고 할 수 있다.<br>
  ![식별자](identifier1.png)

- 식별자인 변수명으로는 메모리상에 존재하는 변수 값을 식별할 수 있고, 함수명으로는 메모리상에 존재하는 함수(자바스크립트에서 함수는 값임)를 식별할 수 있다

### :five: 변수 선언

- 변수, 함수, 클래스 등의 이름과 같은 식별자는 네이밍 규칙을 준수해야 하며, 선언에 의해 자바스크립트 엔진에 식별자의 존재를 알린다.

#### 변수 선언이란?

- 포괄적인 의미

  - 변수를 생성하는 것

- 세부적인 의미

  - 값을 저장하기 위한 메모리 공간을 확보하고 변수명과 확보된 메모리 공간의 주소를 연결(name binding)해서 값을 저장할 수 있게 준비하는 과정

- 변수 선언에 의해 확보된 공간은 확보가 해제(release)되기 전까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되므로 안전하게 사용할 수 있음

- 변수를 사용하기 위해서는 반드시 선언이 필요하며, 선언하지 않은 식별자에 접근하면 `ReferenceError(참조 에러)`가 발생한다.

- ReferenceError<br>
  ![ReferenceError](./RefernceError1.png)<br>
  - 식별자를 통해 값을 참조하려 했으나 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 경우 발생하는 에러

##### var

- 변수를 선언할 때 사용하는 키워드이며 변수(`var`iable)의 앞 세글자를 따온 것이다.

- ES6(ES5에 일부 기능을 추가한 상위 집합)에서 let, const 키워드가 도입되기 전까지 자바스크립트상 변수를 선언할 수 있게 해주는 유일한 키워드

- `var` 뒤에 오는 변수의 이름으로 새로운 변수를 선언할 것임을 지시함

```js
var score; // 변수 선언
```

![var을 이용한 변수 선언](./var1.png)

<br>

- 위 예시를 통해 var 키워드를 이용해서 변수를 선언하면 score이라는 변수명이 등록되고, 해당 변수값이 저장될 메모리 공간을 확보하는 것을 확인할 수 있다.
- 하지만 이 코드는 변수선언만 하였고 변수에 값을 할당하지는 않았다.
- 변수 선언을 통해 확보된 메모리 공간이 비어있다고 생각할 수 있나, 해당 메모리 공간에는 `undefined`값이 암묵적으로 할당되어 있다. (이는 자바스크립트 엔진에 의해 이루어지는 암묵적인 초기화 과정이다)

- undefined

  - 자바스크립트에서 제공하는 원시 타입의 값(primitive value)

###### 자바스크립트의 변수 선언

1. 선언 단계<br>
   변수명을 등록해서 자바스크립트 엔진에 변수의 존재를 알림

2. 초기화 단계<br>
   값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined라는 값을 할당해서 초기화함<br>
   초기화 단계를 거치지 않는 경우 메모리 공간상에는 이전에 다른 애플리케이션이 사용했던 값이 남아 있을 수 있는데 이를 `쓰레기 값 (garbage value)`이라 함<br>
   (값을 할당하지 않은 상태에서 곧바로 변수 값을 참조하는 경우 쓰레기값이 나올 수 있음)

<br>

- `var` 키워드를 사용해서 변수를 선언하는 경우 선언 단꼐와 초기화 단계가 동시에 이루어진다.

```js
var score;

// 선언 단계를 통해 변수명 score 등록
// 초기화 단계를 통해 score에 undefined라는 값을 암묵적으로 할당해서 초기화를 진행함
```

- `var` 키워드는 암묵적으로 초기화를 수행하므로 쓰레기값이 할당될 위험이 없다.

###### 변수명이 등록되는 장소

- 실행 컨텍스트 (자바스크립트 엔진이 소스코드를 평가하여 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 관리하는 영역)
- 자바스크립트 엔진은 실행 컨텍스트를 통해 식별자와 스코프를 관리함

- 선언 단계와 초기화 단계가 동시에 진행됨

###### var의 단점

- 블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원함
  - 이로 인해 의도치 않게 전역 변수가 선언되어 심각한 부작용이 발생하기도 함

###### let & const 의 도입

- var의 단점을 극복하기 위함

##### let

```js
let age;
let age; // error
```

- 재선언이 불가능 (변수명을 중복해서 만드는 실수를 방지함)

##### const

```js
const gender;
const gender;  // error
```

- 재선언이 불가능 (변수명을 중복해서 만드는 실수를 방지함)

<br>

### :six: 변수 선언의 실행시점과 변수 호이스팅

```js
console.log(score); // undefined. 변수 참조
var score; // 변수 선언
```

- 변수 선언문보다 변수 참조가 우선시 일어남 (인터프리터에 의해 순차적 실행)

  - [참고자료 - 인터프리터와 컴파일러](https://wikidocs.net/132948)
  - [참고자료 - 인터프리터와 컴파일러2](https://www.youtube.com/watch?v=Dx2tSsd3aFc&ab_channel=%EC%A0%84%EB%87%8C%ED%95%B4%EC%BB%A4)

- 따라서 undefined가 출력이됨

  - `런타임 (소스코드가 한 줄씩 순차적으로 실행되는 시점)`이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.

- 자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 소스코드의 평가 과정을 거치면서 소스코드를 실행하기 위한 준비를 한다.<br>
  이떄 소스코드 실행을 위한 준비 단계인 소스코드의 평가 과정에서 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 소스코드에서 찾아내 먼저 실행한다. <br>
  그리고 소스코드의 평가 과정이 끝나면 비로소 변수 선언을 포함한 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.

- 즉, 자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행한다.<br>
  따라서 변수 선언이 어디에 위치하는지와 상관없이 어디서든지 변수를 참조할 수 있다.

- 만약 코드가 순차적으로 실행되는 런타임에 변수 선언이 실행된다면 `console.log(score)`실행 시점에는 아직 변수가 선언되기 이전이므로 `Reference Error`가 발생해야 하지만 `undefined`가 출력된다<br>
  이는 변수 선언(선언 단계와 초기화 단계)이 소스코드가 순차적으로 실행되는 런타임 이전 단계에서 먼저 실행된다는 증거이다.<br>
  이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 `변수 호이스팅 (variable hoisting)`이라 한다.

#### 호이스팅

- 스코프 내부 어디서든 변수 선언은 최상위에 선언된 것처럼 행동
- 호이스팅은 스코프 단위로 일어남

- 변수
  - let, const는 ES6에서 생김. 이전 JS버전에서는 var을 사용함
  - var와 let은 유사하므로 바꿔사용해도 크게 문제되지 않음
  - var는 한번 선언된 변수를 다시 선언할 수 있음
  - var는 선언하기 전에 사용할 수 있음
  ```js
  var name; // 1) 갑의 선언
  console.log(name); // 2) undefined
  name = "Danny"; // 3) 값의 할당
  ```
  - 3)부분의 name이 1)로 이동
    - var로 선언한 모든 변수는 코드가 실제로 이동하지는 않지만 실제로 최상단으로 끌어올려진 것처럼 동작함. 이를 `호이스팅`이라 함.
  - 콘솔은 undefined를 출력함
    - 선언은 호이스팅이 되지만, 할당은 호이스팅이 되지 않기 때문이다 (3)의 name이 1)로 끌어올려짐. 'Danny'라는 값은 그자리에 머물러있음)
  - 같은 상황에서 let은 에러가 발생함
  ```js
  console.log(name); // ReferenceError
  let name = "Danny";
  ```
  - let 또한 호이스팅이 발생한다.
  - 여기서 에러가 발생하는 이유는 TDZ(Temporal Dead Zone) 때문이다

##### Temporal Dead Zone

```js
console.log(name); // TDZ
const name = "rachael"; // 함수 선언 및 할당
console.log(name); // 사용 가능
```

- TDZ 영역에 있는 변수들은 사용할 수 없다.
- let과 const는 TDZ의 영향을 받는다 (따라서 할당하기 전에는 사용할 수 없다)<br>
  => 코드를 예측가능하게 하고, 잠재적인 버그를 줄일 수 있음

```js
let age = 20;
function printAge() {
  console.log(age);
}

printAge();
```

- 이 코드는 문제가 없다

```js
let age = 20;

function printAge() {
  // 스코프 단위 시작
  console.log(age); // TDZ
  let age = 15;
} // 스코프 단위 끝

printAge();
```

- 이 코드는 문제가 발생한다
- let 또한 호이스팅이 된다.
- 호이스팅은 스코프 단위로 일어난다.
- 호이스팅이 일어나지 않았다면 함수 밖에서 선언한 `age=20`이 정상적으로 찍혀야 함

###### 변수의 생성과정

1. 선언 단계
2. 초기화 단계 (undefined를 할당해주는 단계)
3. 할당 단계

- var

  - var는 선언과초기화가 동시에 이루어짐
  - 따라서 할당전에 호출을 하면 에러를 뿜지 않고 undefined를 출력
  - 함수 스코프

- let

  - 선언 단계와 초기화 단계가 분리되어 실행됨
  - 호이스팅되면서 선언 단계가 이루어지지만 초기화 단계는 실제 코드에 도달했을 때 이루어지므로 ReferenceError가 발생한다.
  - 블록 스코프

- const

  - 선언과 할당이 동시에 이루어져야 함 (let과 var는 선언만 해두고 나중에 할당하는 것을 허용함)
  - 블록 스코프

  ```js
  let name;
  name = 'Danny';

  var age;
  age = 20;

  const gender;
  gender = 'male';
  ```

  - name과 age는 괜찮지만 const로 선언한 gender 부분에서 에러가 발생함 (선언하면서 할당을 하지 않았기 때문임)

- 블록 스코프

  ```js
  function add() {
    // block level scope
  }
  ```

  ```js
  if() {
    // block level scope
  }
  ```

  ```js
  for (let i = 0; i < 10; i++) {
    // block level scope
  }
  ```

  - 블록 스코프는 모든 코드 블록에서 선언된 변수는 코드 블록 내에서만 유효하며 외부에서는 접근할 수 없다.

  - 코드 블록 (함수, if문, for문, while문, try~catch문 등) 내부에서 선언한 변수는 지역변수이다.

  ```js
  const age = 20;

  if (age < 15) {
    var txt = "학생";
  }

  console.log(txt); // 학생
  ```

  - 예를 들어 if문 내에서 var로 선언된 변수는 if문 밖에서도 사용할 수 있다. 하지만 let과 const는 if문 내에서만 사용할 수 있다.

- 함수 스코프

  - 반면, 함수 스코프는 함수 내에서 선언된 변수만 그 지역변수가 된다.

  ```js
  function add(n1, n2) {
    var result = n1 + n2;
  }

  add(5, 10);
  console.log(result); // ReferenceError
  ```

  - var도 함수 내에서 선언되면 함수 밖에서 사용할 수 없다. 유일하게 벗어날 수 없는 scope가 함수 스코프이다.

- var는 사용하지말고 let&const를 사용하는게 좋다.
  - 예측 가능한 결과를 내고, 버그를 줄일 수 있다.
