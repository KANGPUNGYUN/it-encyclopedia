# 기술면접 질문

## 01. 변수

### 1. 변수 호이스팅이 무엇인지 설명해주세요.

<hr>

#### 대엽

- 함수 선언과 변수 선언은 코드를 실행할 때 해당 선언 스코프가 최상단으로 끌어올려진다. 이러한 현상을 호이스팅이라 한다. var로 선언된 변수는 호이스팅이 되지만 let과 const로 선언된 변수와 상수는 호이스팅이 일어나지 않고 TDZ구역에 배치된다.

#### 민지

- 변수 호이스팅이란 변수를 어느 위치에 선언했는지에 상관없이 유효범위 내 코드의 제일 최상단에 선언된 것처럼 끌여올려지는 현상을 의미합니다.
  변수 선언문 뿐만 아니라 모든 식별자도 호이스팅이 되며, 이때 호이스팅은 실제로 끌어올려지는 것이 아니라 끌어올려진 것처럼 보입니다.
  호이스팅은 런타임 이전에 실행되기 때문에 식별자의 선언은 호이스팅 되지만, 런타임에 실행되는 값의 할당은 호이스팅 되지 않습니다.

#### 다은

- 변수가 선언된 위치에 상관없이 최상단에서 선언한 것처럼 끌어올려지는 자바스크립트 고유의 특징을 의미합니다. `var`로 선언한 변수의 경우 호이스팅 시 `undefined`로 변수를 초기화하며, `let`과 `const`로 선언한 변수의 경우 변수를 초기화하지 않습니다.

#### 선아

- 변수 호이스팅은 변수 선언문이 코드의 최상단으로 끌어올려지는 현상을 말합니다. 변수 선언뿐 아니라 모든 식별자는 호이스팅 되는데, 여기서 주의할 점은 선언은 호이스팅 되지만 할당은 호이스팅 되지 않는다는 점입니다.

#### 광렬

- 메모리 공간을 선언전에 미리 할당을 하는것을 의미합니다. 또한 초기화를 제외한 선언은 코드 최상단 위치로 끌어올려지는 것 처럼 보입니다. 자바스크립트에서 호이스팅은 초기화를 제외한 선언만 호이스팅 대상 입니다.

<br>

### 2. 변수 선언과 초기화의 차이점을 설명해주세요.

<hr>

#### 대엽

- 변수 선언은 값을 저장하기 위해 메모리 공간을 확보하고 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 과정이다. 변수 초기화는 값을 저장하기 위해 메모리 공간을 확보하고 최초로 값을 할당하는 것을 뜻한다. 자바스크립트 상 초기화 단계에서 암묵적으로 undefined값을 할당한다. 초기화 단계를 거치지 않은 상태에서 변수 값을 참조하는 경우 쓰레기값이 나올 수 있다.

#### 민지

- 변수 선언은 변수명을 비롯한 모든 식별자에 대해 실행 컨텍스트에 등록해서 자바스크립트 엔진에 변수의 존재를 알리는 것을 말합니다.
  초기화는 값을 저장하기 위해 메모리 공간을 확보하고, 암묵적으로 undefined를 할당해 초기화 하는 것을 말합니다.

#### 다은

- 변수의 선언 단계에서는 변수를 실행 컨텍스트의 변수 객체에 등록하는 것이며, 초기화 단계에서는 실행 컨텍스트에 등록된 변수 객체에 대한 메모리를 확보하고 값을 할당합니다.

#### 선아

- 변수 선언은 실행 컨텍스트에 변수명을 등록해서 자바스크립트 엔진에 변수 존재를 알리는 것이고, 초기화는 값을 저장하기 위해 메모리 공간을 확보하고 변수에 최초로 값을 할당하는 것을 말합니다.

#### 광렬

- 선언은 변수를 정의하는 것을 의미하며, 그 종류에는 var,let,const 가 있습니다. 할당은 변수가 선언이 되고나서 대입 연산자를 통하여 값을 집어 넣어주는 것을 의미합니다. 마지막으로 초기화는 변수를 선언함과 동시에 값을 넣어주는 것 입니다.

<br>

### 3. `let` , `const` , `var` 각각을 설명해주세요.

<hr>

#### 대엽

- `var`

  - 재선언 가능가능
  - 선언하기전에 사용할 수 있음
  - 선언단계와 초기화 단계가 동시에 이루어짐
  - var로 선언된 모든 변수는 코드가 실제로 이동하지 않지만 실제로 최상단으로 끌어올려진 것처럼 동작함 (호이스팅)
  - 함수 레벨 스코프를 지원

- `let`

  - 재선언 불가능 (변수명 중복으로 인한 실수 방지)
  - 선언단계와 초기화 단계가 분리되어 실행됨
  - 할당하기 전에 사용할 수 없음 (TDZ의 영향 => 버그 감소)
  - 블록 레벨 스코프를 지원

- `const`
  - 재선언 불가능 (변수명 중복으로 인한 실수 방지)
  - 선언단계와 초기화 단계가 분리되어 실행됨
  - 할당하기 전에 사용할 수 없음 (TDZ의 영향 => 버그 감소)
  - 블록 레벨 스코프를 지원

#### 민지

- 각각 변수 선언을 하는 키워드로 var는 재선언과 재할당이 가능하며, let은 재선언은 불가능하지만 재할당이 가능하고, const는 재선언과 재할당 모두 불가합니다.
  함수 레벨 스코프를 지원하는 var 키워드는 의도치 않은 전역 변수 선언으로 예상하지 못한 에러를 발생하기 때문에 이런 문제를 보완하기 위해
  ES6 이후에 블록 레벨 스코프를 지원하는 let, const 키워드가 도입되었습니다.

#### 다은

- `var`는 함수 레벨 스코프로 중복 선언과 재할당이 가능하기 때문에 값이 바뀔 수 있다는 문제점이 있습니다. 이를 보완하기 위해 ES6부터 블록 레벨 스코프인 `let`과 `const`가 추가되었습니다. `let`은 재할당만 가능하며 `const`는 재선언, 재할당 모두 불가능하기 때문에 선언과 동시에 할당을 해야하는 특징을 가지고 있습니다.

#### 선아

- 변수 선언 시에 사용하는 키워드입니다. var는 재선언, 재할당이 가능하고, let은 재할당만 가능하고, const는 재선언, 재할당 모두 불가능합니다. var는 함수 레벨 스코프인데, var의 문제를 보완하기 위해 ES6에 블록 레벨 스코프인 let과 const가 도입 되었습니다.

#### 광렬

- 먼저 공통적으로 전부 호이스팅이 됩니다. 차이는 각각 설명드리겠습니다. var 같은경우는 중복선언,재할당,호이스팅 전부 가능하며, 유효범위를 의미하는 스코프는 함수 스코프입니다. let 은 중복선언이 불가능하며, 재할당,호이스팅은 가능합니다. 스코프는 블록 스코프입니다. 마지막으로 const 같은 경우에는 중복선언과 재할당이 불가능합니다. 호이스팅은 가능합니다. 스코프는 블록스코프입니다.
  간단히 호이스팅 부분에 대해 설명하자면, let,const,var 모두 호이스팅은 일어나지만, let 과 const 같은 경우에는 일시적 사각지대에 빠지게 되어 변수할당이 되기전에는 사용이 불가능하여, 마치 호이스팅이 되지 않는 것 처럼 보이게 된다.

<br>

### 4. 선언하지 않은 식별자에 접근하면 어떤 문제가 발생하며, 그 이유를 설명해주세요.

<hr>

#### 대엽

- Reference Error가 발생함. 변수를 사용하기 위해서는 선언이 필요한데 선언을 하지 않았다. 그렇다면 값을 저장하기 위한 메모리 공간을 확보하고 이 메모리 공간의 주소에 연결하는 과정이 되기 이루어지지 않았는데, 존재하지 않는 메모리 공간의 주소값을 참조하려고하니까 참조에러가 발생하는 것이다.

#### 민지

- 레퍼런스 에러(참조애러)가 발생합니다. 레퍼런스 에러는 식별자를 통해 값을 참조하려 했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러입니다.
  var는 선언, 초기화, 할당이 동시에 이루어지기 때문에 초기값인 undefined가 출력되어 식별자를 통해 값을 참조할 때 레퍼런스 에러가 발생하지 않지만,
  let과 const는 선언, 초기화, 할당 단계가 각각 따로 이루어지기 때문에 var와 다르게 참조 에러가 발생합니다.

#### 다은

- 선언하지 않은 식별자에 접근할 경우 레퍼런스 에러가 발생합니다. 이는 자바스크립트 엔진에서 등록된 식별자를 찾지 못했기 때문에 발생하는 에러입니다.

#### 선아

- 선언하지 않은 식별자에 접근하면 레퍼런스 에러가 발생합니다. 변수 호이스팅이 일어나도 초기화 단계 이전에 식별자에 접근한다면 마찬가지로 레퍼런스 에러가 출력됩니다. 그렇지만 var는 선언과 초기화가 동시에 이루어지기 때문에 초기화된 값인 undefined가 출력됩니다.

#### 광렬

- 레퍼런스 에러가 발생합니다. 그이유는 레퍼런스 에러의 정의에 답이 있습니다. 레퍼런스 에러는 현재 범위에서 존재하지 않거나 초기화 되지 않은 변수를 참조했을때 발생하는 에러입니다. 이는, 질문과 같이 초기화 이전에 선언조차 하지않은 식별자에 접근한다면 당연히 나타날 에러인것 입니다.
