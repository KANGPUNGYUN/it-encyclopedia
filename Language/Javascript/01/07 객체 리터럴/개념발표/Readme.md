# 자바스크립트 딥다이브 개념 발표

## 07. 객체 리터럴

### 1. 객체란?

- 자바스크립트는 객체 기반의 프로그래밍 언어 → 원시 값을 제외한 모든 것이 객체
- 객체 타입: 다양한 타입의 값(원시 값 또는 다른 객체)를 하나의 단위로 구성한 복합적 자료구조 <br>
  → **변경 가능한 값** <br>
  _→ 원시 타입: 단 하나의 값, 변경 불가능_
- 0개 이상의 **프로퍼티로 구성된 집합**이며 key 와 value 값으로 구성됨
- 함수: 일급 객체로 프로퍼티 값으로 사용할 수 있으며, 객체의 프로퍼티 값인 함수를 **메소드**라 지칭
  ⇒ 객체: 프로퍼티와 메소드로 구성된 집합체

  - 프로퍼티: 객체의 상태를 나타내는 값(data)
  - 메소드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)

  <br>

### 2. 객체 리터럴에 의한 객체 생성

- C++, 자바 (클래스 기반 객체지향 언어): 클래스를 사전에 정의하고 필요한 시점에 new 연산자와 함께 생성자를 호출하여 인스턴스를 생성하는 방식으로 객체 생성
    <aside>
    📎 **인스턴스**
    클래스에 의해 생성되어 메모리에 저장된 실체
    객체지향 프로그래밍에서 객체는 클래스와 인스턴스를 포함한 개념
    클래스는 인스턴스를 생성하기 위한 템플릿의 역할
    
    </aside>

- 자바스크립트 (프로토타입 기반 객체지향 언어): 다양한 객체 생성 방법 지원
  - 객체 리터럴 _→ 가장 일반적이고 간단한 방법_
  - Object 생성자 함수
  - 생성자 함수
  - Object.create 메소드
  - 클래스(ES6)
- 객체 리터럴: 중괄호 `{ ... }` 내에 0개 이상의 프로퍼티를 정의, 변수에 할당되는 시점에 자바스크립트 엔진은 객체 리터럴을 해석해 객체를 생성 <br>
  → 중괄호는 코드 블록을 의미하지 않음 <br>
  → 객체 리터럴의 닫는 중괄호 뒤에는 `;` 을 붙임

  <br>

### 3. 프로퍼티

- 프로퍼티를 나열할 때는 `,` 로 구분
- 프로퍼티로 사용할 수 있는 값
  - 프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 심벌 값 → 이외의 값은 문자열로 암묵적 타입 변환
  - 프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값
- 프로퍼티 키: 프로퍼티 값에 접근할 수 있는 이름으로서 식별자 역할
  - 식별자 네이밍 규칙을 따라야 하는 것은 아니지만 **따르지 않을 경우 따옴표를 반드시 사용**
    ```js
    var person = {
      firstName: "Seona",
      "last-name": "Bang",
    };
    ```
- 한 객체 내에 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 걸 덮어씀

<br>

### 4. 메소드

- 프로퍼티 함수일 경우 일반 함수와 구분하기 위해 메소드라 지칭 <br>
  → 객체에 묶여 있는 함수

  <br>

### 5. 프로퍼티 접근

- 프로퍼티 접근 연산자
  1. 마침표 표기법(dot notation)
  2. 대괄호 표기법(bracket notation) → **프로퍼티 키는 반드시 `''` 로 감싼 문자열이어야 함 (숫자로 이루어진 문자열인 경우에만 생략 가능)**
  - 접근법 2가지 모두 사용 가능
  - 프로퍼티 접근 연산자의 좌측: 객체 표현식
  - 프로퍼티 접근 연산자의 우측/내부: 프로퍼티 키
- 프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않는 이름은 **반드시 대괄호 표기법** 사용

<br>

### 6. 프로퍼티 값 갱신

- 이미 존재하는 프로퍼티에 값을 할당하면 값이 갱신됨 → 프로퍼티 값 **재할당 가능**

<br>

### 7. 프로퍼티 동적 생성

- 존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 **동적으로 생성되어 추가되고 프로퍼티 값이 할당됨**

<br>

### 8. 프로퍼티 삭제

- `delete` 연산자 사용 → 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 함
- 존재하지 않는 프로퍼티를 삭제하면 에러 없이 무시됨

  ```js
  var person = {
  	name = 'Bang'
  };

  //프로퍼티 동적 생성
  person.age = 27;

  delete person.age; //프로퍼티 삭제

  delete person.address; //에러 발생없이 무시됨

  console.log(person);
  // {name: "Bang"}
  ```

  <br>

### 9. ES6에 추가된 객체 리터럴의 확장 기능

#### 9.1 프로퍼티 축약 표현

- 객체 리터럴에서 프로퍼티 값은 변수에 할당된 값, 즉 식별자 표현식일 수 있음
- ES6에서 변수명과 프로퍼티 키가 동일한 이름일 때, 프로퍼티 키를 생략 가능

  ```js
  let x = 1,
    y = 2;

  //프로퍼티 축약 표현
  const obj = { x, y };

  console.log(obj);
  // {x: 1, y: 2}
  ```

  <br>

#### 9.2 계산된 프로퍼티 이름

- 문자열 또는 문자열로 타입 변환할 수 있는 값으로 평가되는 표현식을 사용해 프로퍼티 키를 동적 생성

  ```js
  const prefix = "prop";
  let i = 0;

  const obj = {
    [`${prefix}-${++i}`]: i,
    [`${prefix}-${++i}`]: i,
    [`${prefix}-${++i}`]: i,
  };

  console.log(obj);
  // {prop-1: 1, prop-2: 2, prop-3: 3}
  ```

  <br>

#### 9.3 메소드 축약 표현

- 메소드를 정의하려면 프로퍼티 값으로 함수를 할당 → function 키워드를 생략한 축약 표현 사용 가능

  ```js
  const obj = {
  name: 'Bang',

  //ES5 (이전)
    sayHi: function() {
      console.log('Hi! ' + this.name);
    }
  //ES6 메소드 축약 표현
    sayHi() {
      console.log('Hi! ' + this.name);
    }
  };

  obj.sayHi();
  //Hi! Bang
  ```

<br>
