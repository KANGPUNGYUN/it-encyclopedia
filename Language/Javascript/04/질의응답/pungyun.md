# 4주차 질의응답 (딥다이브 23장-26장)

<br>

## 23. 실행 컨텍스트

---

1. 소스코드의 타입에 대해 설명해주세요.

- ECMAscript 사양은 소스코드를 4가지 타입으로 구분합니다. 4가지 타입의 소스코드에는 전역코드, 함수코드, eval코드, 모듈코드가 있습니다. 다음의 소스코드들은 실행 컨텍스트를 생성합니다.

전역코드는 전역에 존재하는 소스코드를 말하며, 전역에 정의된 함수나 클래스 등의 내부코드는 포함되지 않습니다.

함수코드는 함수 내부에 존재하는 소스코드를 말하며, 함수 내부에 중첩된 함수나 클래스 등의 내부 코드는 포함되지 않습니다.

eval코드는 빌트인 전역 함수인 eval함수에 인수로 전달되어 실행되는 소스코드를 의미합니다.

모듈코드는 모듈 내부에 존재하는 소스코드를 말하며 모듈 내부의 함수나 클래스 등의 내부코도는 포함하지 않습니다.

2. 실행 컨텍스트 생성 과정에 대해 설명해주세요.

- 실행 컨텍스트는 자바스크립트 엔진이 코드를 처음 실행할 때 빈 전역 실행 컨텍스트를 생성하고, 콜 스택에 푸쉬합니다. 그리고 엔진이 스크립트를 한 줄씩 읽어 내려가면서 함수 호출을 발견할 때마다 함수의 실행 컨텍스트를 스택에 푸쉬합니다. 즉 함수 실행 컨텍스트는 함수가 실행될 때마다 생성됩니다.

3. 실행 컨텍스트에 대해 말해보세요

- 실행 컨텍스트란 실행할 코드에 제공할 환경 정보들을 모아놓은 객체입니다.동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하고 이를 콜 스텍에 쌓아올렸다가 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장합니다.

4. 식별자 검색 과정에 대해 설명해주세요.

- 식별자를 검색할 때는 실행 중인 실행 컨텍스트에서 식별자를 검색하기 시작합니다. 만약 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색할 수 없으면 외부 렉시컬 환경에 대한 참조가 가리키는 렉시컬 환경, 즉 상위 스코프로 이동하여 식별자를 검색합니다. 만약 전역 렉시컬 환경에서도 검색할 수 없는 식별자라면 참조 에러를 발생시킵니다.

5. 실행 컨텍스트를 활용하여, var로 선언된 변수가 어떻게 호이스팅되는지 설명해주세요.

- 실행 컨택스트에는 생성단계와 실행단계로 나누어서 설명할 수 있습니다. 생성단계는 선언문만 실행해서 환경레코드에 기록하는 단계이며, 실행단계는 선언문 이외의 코드를 실행하여 환경레코드의 값을 업데이트하는 단계입니다. 먼저 생성단계에서는 빈 전역 실행 컨텍스트를 생성하여 콜 스택에 푸쉬한 뒤, 전역 코드를 스캔하면서 선언할 것이 있는 확인하여 실행 컨텍스트에 var로 선언된 새로운 식별자를 기록합니다. var로 선언되었기 때문에 선언과 동시에 undefined로 초기화하여 값을 기록합니다. 선언문이 모두 실행되었으면, 나머지 코드도 순차적으로 진행하여 환경레코드의 값을 업데이트해줍니다. 이때 var로 선언한 변수의 할당문이 있다면, 실행 단계에서 환경레코드의 값이 업데이트됩니다.

<br>

## 24. 클로저

---

1. 클로저에 대해서 설명해주세요.

- 클로저란 어떤 함수에서 선언한 변수를 참조하는 내부함수를 외부로 전달할 경우 외부함수의 실행 컨텍스트가 종료된 이후에도 해당 변수가 사라지지 않는 현상을 의미합니다.

2. 캡슐화를 정보 은닉 개념과 함께 설명해주세요.

- 캡슐화는 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것을 의미하며, 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용되기도 하여 정보 은닉이라고도 부릅니다.

3. 클로저를 사용하는 이유는 무엇인가요?

- 클로저는 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용합니다.

4. 클로저를 어떻게 생성하나요?

- 내부함수가 상위 스코프의 식별자를 참조하고 있고, 그 내부함수를 그 상위 스코프 바깥에서 사용했을 때, 식별자를 수정할 수 없는 클로저가 생성됩니다.

5. 클로저의 장점과 단점에 대해 설명해주세요.

- 클로저의 장점으로는 식별자를 안전하게 은닉하고 캡슐화할 수 있다는 점입니다. 반대로 클로저의 단점으로 특정 식별자를 은닉하기 때문에 식별자가 그대로 남아 메모리를 소모하게 됩니다.

<br>

## 25. 클래스

---

1. 클래스와 함수 생성자의 차이점은 무엇인가요?

- 생성자 함수는 new 연산자와 함께 호출하여 객체를 생성하는 함수를 말합니다. 클래스도 마찬가지로 new 연산자와 함께 호출하여 객체를 생성합니다. 다만 생성자 함수는 new 연산자를 생략하면 생성자 함수는 일반 함수로 호출되고 클래스는 타입 에러가 발생합니다. 또 둘 다 상속이란 개념이 존재하지만, 생성자 함수는 프로토타입의 체인에서 인스턴스가 프로토타입의 프로퍼티를 상속받는거고 클래스는 extends 키워드를 통해 클래스 상속에 의해 확장되는 개념입니다.

2. 정적 메서드와 프로토타입 메서드의 차이점은 무엇인가요?

- 정적 메서드와 프로토타입 메서드는 자신이 속해 있는 프로토타입 체인이 다르며, 정적메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출합니다. 또한 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있습니다.

3. 클래스의 상속에 대해서 말해보세요

- 상속에 의한 클래스 확장은 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의합니다. 클래스 상속을 통해 상속받는 클래스의 속성을 그대로 사용할 수 있습니다.

4. 클래스의 정의에 대해 설명해주세요.

- 클래스는 객체를 생성하기 위한 템플릿입니다. 그리고 클래스는 데이터와 이를 조직하는 코드를 하나로 추상화합니다. 자바스크립트에서 클래스는 사실 특별한 함수이며, 기존 프로토타입 기반 패턴처럼 사용할 수 있도록 하는 문법적 설탕으로 볼 수도 있습니다. 하지만 자바스크립트의 클래스는 extends와 super 등의 상속관계 구현을 더욱 간결하고 명료하게 사용할 수 있는 키워드도 제공하여 단순한 설탕적 문법이라기보다 새로운 객체 생성 메커니즘이라고 할 수 있습니다.

5. 정적 클래스 멤버를 만드는 이유는 무엇인가요?

- 정적 메서드는 인스턴스로 호출할 수 없기 때문에, 정적 클래스 멤버를 생성한다면 이름 충돌 가능성을 줄여주고 관련 함수들을 구조화할 수 있는 효과가 있습니다.

<br>

## 26. ES6 함수의 추가 기능

---

1. 화살표 함수와 일반 함수의 차이를 설명해주세요.

- 화살표 함수와 일반 함수의 차이점으로 일반 함수는 constructor이며 prototype 프로퍼티를 가지지만, 화살표함수는 non-constructor이며 prototype 프로퍼티를 가지지 않습니다.

2. 매개변수 기본값에 대해 설명해주세요.

- 자바스크립트 엔진은 매개변수의 개수와 인수의 개수를 체크하지 않기 때문에 함수를 호출할 때 매개변수의 개수만큼 인수를 전달하지 않아도 에러가 발생하지 않습니다. 인수가 전달되지 않은 매개변수의 값은 undefined입니다. ES6부터 도입된 매개변수 기본값을 사용하면 함수 내 인수 체크 및 초기화가 가능합니다.

3. ES6의 메서드에 대해 설명해주세요.

- ES6 사양에서 메서드는 메서드 축약 표현으로 정의된 함수만을 의미하며, 인스턴스를 생성할 수 없는 non-constructor입니다. ES6의 메서드는 인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없고 프로토타입도 생성하지 않습니다.

4. Rest 파라미터에 대해 설명해주세요.

- Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다. 또한 Rest 파라미터는 이름 그대로 먼저 선언된 매개변수에 할당된 인수를 제외한 나머지 인수들로 구성된 배열이 할당됩니다.

5. Map 오브젝트에 대해 설명해주세요.

- Map 객체는 키와 값의 쌍으로 이루어진 컬렉션입니다, Map 객체는 객체와 유사하지만 객체에는 이터러블이 아니지만, Map 객체는 이터러블인 객체이고 키로 사용할 수 있는 값으로 객체는 문자열과 심벌 값을 사용하는 반면에 Map 객체는 객체를 포함한 모든 값이 해당되는 차이가 있습니다.
